## 我认为的重点

1. 事件处理程序的顺序是什么?
2. ​













## 事件

1. 添加事件

   只用`elementxxx.addEventListener("AAA", fnName, boolean)`
   1. "AAA"在http://javascript.ruanyifeng.com/dom/event-type.html中找
   2. fnName 指的是函数的名字
   3. boolean 为false === 冒泡

2. 移除事件

   `element.removeEventListener("AAA", fnName, boolean)`


## 事件的三个阶段

1. 代码: http://js.jirengu.com/tofisalewa/1/edit?

   ![未命名文件 (9).png](http://upload-images.jianshu.io/upload_images/5529438-3ca1cd80186bc2c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. 点击4区域,解释打印结果

   注意点: 

   1. div3有两个函数,注意执行顺序
   2. div3之后有个×, 实现的代码

3. 如果我点击3区域,打印什么?

   1. 打印`冒泡2, 3 ,33333`

4. 如果div3既有冒泡,又有捕获,执行顺序是什么?    先执行捕获阶段的执行代码,再执行冒泡阶段的执行代码

5. 如果div4既有冒泡,又有捕获,执行顺序是什么?    看捕获的执行代码和冒泡的执行代码谁在前面谁先执行,这时候不管捕获和冒泡了,(特殊)

6. 一个 DOM 结点事件处理程序的顺序: 

   1. 先捕获后冒泡
   2. 哪个代码在前面, 哪个代码就先执行
   3. 一般情况下, 是先看1再看2
   4. 当 DOM 结点(如 demo 的 div4 )之后没有 DOM 结点, 那个按照第2条规则处理







## 草稿

1. this指向问题

   - 如果是使用`nodexxx.addEventListener("click", hello, false)`,则 hello 函数内的 this 指向 nodexxx

2. `event.target`与`event.currentTarget`区别?

3. 防止默认事件: `event.preventDefault()`

4. 防止事件传播: `event.stopPropagation()`

5. 写一个 dismissible propover (点击别处关闭浮层) 组件

6. 第一版组件

   1. 最好的方法是画出 DOM 节点树

   2. 然后列出所有的**在何处发生的事件**

   3. 接着和 DOM 节点数进行对比. 写代码, 原则就是完全消除 DOM 的冒泡阶段

   4. 代码:http://js.jirengu.com/loruyikobe/1/edit?

   5. 图例

      ![未命名文件 (2).png](http://upload-images.jianshu.io/upload_images/5529438-c79e27e96e72be84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

7. 第二版组件

   1. 第一版的组件不好,不好的原因是当我点页面的其他位置时, popover的display: none 根本没有必要起作用,我想要的是当 popover 的display: block的时候, 点击页面的其他位置, popover的display: none才起作用, 该怎么写?
   2. ​

   ​

8. 所以我写出了第一版dismissible propover组件

9. ​

10. 你可以在事件处理程序中给其他节点添加事件监听AA,**在冒泡的过程,添加事件的监听AA是在本次冒泡阶段触发的**

11. 对于一个经典的事件监听函数,明确一些概念

   ```
   btn.addEventListener("click", function(){
     //这个函数就是事件处理程序
     console.log(1)
   })
   ```

-  事件 === 用户的动作 ===在上面的代码就是"click"

-  事件监听 === 上面的整个代码

-  事件流 === 事件在DOM节点树传播的顺序

-  事件处理程序 === 在上面的代码就是`console.log(1)`

   ​

   ​